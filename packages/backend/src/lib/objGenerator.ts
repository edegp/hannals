/**
 * 寸法から3DオブジェクトのOBJファイルを生成する
 *
 * 座標系: Z-up（CAD標準）
 * - X = 幅（左右）
 * - Y = 奥行き（前後）
 * - Z = 高さ（上下）
 *
 * CargoViewerで-90度X回転されてThree.js座標系（Y-up）に変換される
 */

export interface BoxDimensions {
  id: string
  name?: string
  x_mm: number  // 幅
  y_mm: number  // 奥行き
  z_mm: number  // 高さ
  posX?: number // 配置位置X
  posY?: number // 配置位置Y
  posZ?: number // 配置位置Z（高さ方向）
  rotation?: number // 回転角度（度、Z軸周り）
}

/**
 * 単一のボックスのOBJデータを生成（Z-up座標系）
 */
export function generateBoxObj(
  dimensions: BoxDimensions,
  vertexOffset: number = 0
): { vertices: string; faces: string; vertexCount: number } {
  const { x_mm, y_mm, z_mm, posX = 0, posY = 0, posZ = 0, rotation = 0 } = dimensions

  // mmからmに変換
  const width = x_mm / 1000   // X方向
  const depth = y_mm / 1000   // Y方向
  const height = z_mm / 1000  // Z方向（高さ）
  const px = posX / 1000
  const py = posY / 1000
  const pz = posZ / 1000

  // 回転を適用（Z軸周りの回転、Z-up座標系）
  const rad = (rotation * Math.PI) / 180
  const cos = Math.cos(rad)
  const sin = Math.sin(rad)

  // ローカル頂点（Z-up座標系: X=幅, Y=奥行き, Z=高さ）
  const localVertices = [
    [0, 0, 0],              // 左手前下
    [width, 0, 0],          // 右手前下
    [width, depth, 0],      // 右奥下
    [0, depth, 0],          // 左奥下
    [0, 0, height],         // 左手前上
    [width, 0, height],     // 右手前上
    [width, depth, height], // 右奥上
    [0, depth, height],     // 左奥上
  ]

  // 回転と平行移動を適用（Z軸周りの回転）
  const transformedVertices = localVertices.map(([x, y, z]) => {
    // Z軸周りの回転
    const rotX = x * cos - y * sin
    const rotY = x * sin + y * cos
    // 平行移動
    return [rotX + px, rotY + py, z + pz]
  })

  // OBJ形式で頂点を出力
  const vertices = transformedVertices
    .map(([x, y, z]) => `v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}`)
    .join('\n')

  // 面の定義（1始まりのインデックス、オフセット適用）
  // 頂点順序: 0=左手前下, 1=右手前下, 2=右奥下, 3=左奥下, 4=左手前上, 5=右手前上, 6=右奥上, 7=左奥上
  const o = vertexOffset + 1
  const faces = [
    `f ${o} ${o + 3} ${o + 2} ${o + 1}`,     // 底面 (Z=0)
    `f ${o + 4} ${o + 5} ${o + 6} ${o + 7}`, // 上面 (Z=height)
    `f ${o} ${o + 1} ${o + 5} ${o + 4}`,     // 前面 (Y=0)
    `f ${o + 2} ${o + 3} ${o + 7} ${o + 6}`, // 背面 (Y=depth)
    `f ${o} ${o + 4} ${o + 7} ${o + 3}`,     // 左面 (X=0)
    `f ${o + 1} ${o + 2} ${o + 6} ${o + 5}`, // 右面 (X=width)
  ].join('\n')

  return { vertices, faces, vertexCount: 8 }
}

/**
 * 複数のボックスから単一のOBJファイルを生成
 */
export function generateMultiBoxObj(boxes: BoxDimensions[]): string {
  const lines: string[] = [
    '# Generated by Hannals',
    `# ${boxes.length} items`,
    '',
  ]

  let vertexOffset = 0

  for (const box of boxes) {
    lines.push(`# Item: ${box.name || box.id}`)
    lines.push(`o ${box.id}`)

    const { vertices, faces, vertexCount } = generateBoxObj(box, vertexOffset)
    lines.push(vertices)
    lines.push(faces)
    lines.push('')

    vertexOffset += vertexCount
  }

  return lines.join('\n')
}

/**
 * 荷物アイテムからOBJ文字列を生成（配置済み荷物用）
 */
export function generatePlacedItemsObj(
  items: Array<{
    id: string
    itemId?: string
    x_mm: number
    y_mm: number
    z_mm: number
    posX: number
    posY: number
    posZ: number
    rotation?: number
  }>
): string {
  const boxes: BoxDimensions[] = items.map((item) => ({
    id: item.itemId || item.id,
    x_mm: item.x_mm,
    y_mm: item.y_mm,
    z_mm: item.z_mm,
    posX: item.posX,
    posY: item.posY,
    posZ: item.posZ,
    rotation: item.rotation || 0,
  }))

  return generateMultiBoxObj(boxes)
}
